<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Post-rsses on Eric Weise</title>
    <link>http://eweise.com/post/index.xml</link>
    <description>Recent content in Post-rsses on Eric Weise</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>US-EN</language>
    <copyright>All rights reserved - 2017</copyright>
    <lastBuildDate>Mon, 12 Jun 2017 22:00:06 -0800</lastBuildDate>
    <atom:link href="http://eweise.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Pushing Side Effects to the Side</title>
      <link>http://eweise.com/post/sideeffects/</link>
      <pubDate>Mon, 12 Jun 2017 22:00:06 -0800</pubDate>
      
      <guid>http://eweise.com/post/sideeffects/</guid>
      <description>&lt;p&gt;Functional programming provides a treasure trove of useful patterns. One pattern I want to highlight is pushing side effects to the edges of your application, because this can be applied to any type of program, not just functional ones. Side effects are calls which interact outside of the application&amp;rsquo;s environment. Examples of side effects are making an Http call or persisting data to the database, or even getting the current time. By isolating these types of calls, we can more easily test our application&amp;rsquo;s code in a deterministic manner. This post will provide an example of how to isolate side effects using an example from a refactoring I did recently at work.&lt;/p&gt;

&lt;p&gt;The example use case is similar to Google Calendar where events are scheduled according to time. Some of the events are one-time events and some re-occur over a period of time. The recurring events can repeat daily, weekly or monthly forever or for a specified number of times. The initial code implementation looked similar to the following;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class EventService {

  public List&amp;lt;RecurringEvent&amp;gt; generateRecurringEvents(RecurringEvent recurringEvent) {
    List&amp;lt;RecurringEvent&amp;gt; generatedEvents = new ArrayList&amp;lt;&amp;gt;();
    LocalDate nextDate = recurringEvent.startDate;
    int generatedCount = 0;

     while(generatedCount &amp;lt; recurringEvent.maxNumber
           &amp;amp;&amp;amp; !nextDate.isAfter(recurringEvent.endDate))) {

        RecurringEvent newEvent = createEvent(recurringEvent, nextDate);
        entityManager.persist(newEvent);
        generatedEvents.add(newEvent);
        generatedCount++;
        nextDate = Recurrence.nextDate(nextDate, recurringEvents.repeatPattern);
    }
    return generatedEvents;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code takes a RecurringEvent as an argument and generates more recurring events based on the repeatPattern pattern defined in the original event. The generation stops when either the EndDate or maxNumberOfInstances is reached. To test this method we would need code similar to the following;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
class EventServiceTest extends SpringyTest {

  @Autowired
  private EntityManager EntityManager

  private EventService eventService = new EventService(entityManager);

  @test
  public void testGenerateRecurringEvents() {
    RecurringEvent recurringEvent = RecurringEventFixture.create();
    List&amp;lt;RecurringEvent&amp;gt; generatedEvents = eventService.generateRecurringEvents(recurringEvents);

    // assert the correct number of events were generated
    Assert.assertEquals(4, generateEvents.size());
  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While the test looks fairly straightforward, it incurs a large performance penalty since we need to wire up the database and any other dependencies in the Spring configuration. On our project, this takes at least 20 seconds which really hurts productivity when trying to work in a TDD fashion.
If we refactored the code to push side effects outside of our business logic, then we would have much faster and easier to test code. The following refactors the EntityManager outside of the generateRecurringEvents method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class EventService {

  public void generateAndPersistRecurringEvents(RecurringEvent recurringEvent) {
      List&amp;lt;RecurringEvent&amp;gt; newEvents = generateRecurringEvents(recurringEvent);
      newEvents.forEach(EntityManager::persist);
  }

  public List&amp;lt;RecurringEvent&amp;gt; generateRecurringEvents(RecurringEvent recurringEvent) {
    List&amp;lt;RecurringEvent&amp;gt; generatedEvents = new ArrayList&amp;lt;&amp;gt;();
    LocalDate nextDate = recurringEvent.startDate;
    int generatedCount = 0;

     while(generatedCount &amp;lt; recurringEvent.maxNumber
           &amp;amp;&amp;amp; !nextDate.isAfter(recurringEvent.endDate))) {

        RecurringEvent newEvent = createEvent(recurringEvent, nextDate);
        entityManager.persist(newEvent);
        generatedEvents.add(newEvent);
        generatedCount++;
        nextDate = Recurrence.nextDate(nextDate, recurringEvents.repeatPattern);
    }
    return generatedEvents;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I made a very simple change to remove the side effect &lt;code&gt;EntityManager.persist&lt;/code&gt; out of the business logic and into a separate method. Notice that I was also able to change generateRecurringEvents to be static because the method no longer depends on any state other than its inputs. Our test becomes a simple unit test instead of a Spring/database type integration test.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class EventServiceTest  {

  @test
  public void testGenerateRecurringEvents() {
    RecurringEvent recurringEvent = RecurringEventFixture.create();
    List&amp;lt;RecurringEvent&amp;gt; generatedEvents = EventService.generateRecurringEvents(recurringEvents);

    // assert the correct number of events were generated
    Assert.assertEquals(4, generateEvents.size());
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The change I made may seem a bit obvious but take a look at your codebase. How many methods could you turn into simple pure function calls by simply removing side effect calls such as repositories from your business logic? Most projects I have worked on, make no attempt at this. Instead, repository calls are sprinkled throughout the service layer code. In general the pattern is;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Retrieve all the data necessary to perform your business logic (side effect code).&lt;/li&gt;
&lt;li&gt;Perform the business logic using in-memory data (pure functions).&lt;/li&gt;
&lt;li&gt;Persist changes to the database (side effect code).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These three steps can&amp;rsquo;t be followed every time but when it can, the code will be much easier to test.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Akka Cluster Example</title>
      <link>http://eweise.com/post/akka-cluster-example/</link>
      <pubDate>Wed, 05 Feb 2014 22:00:06 -0800</pubDate>
      
      <guid>http://eweise.com/post/akka-cluster-example/</guid>
      <description>

&lt;p&gt;Akka provides powerful clustering capabilities but reading through the &lt;a href=&#39;http://doc.akka.io/docs/akka/2.3.2/scala/cluster-usage.html&#39;&gt;online docs&lt;/a&gt; it may not be obvious how to set it up for your particular needs. For my use case, I wanted to create multiple actors representing a particular service that would run on more that one machine. If one machine failed, actors on other machines could still handle the requests, as in a typical high availability scenario. In addition, I did not want the calling actor to have any knowledge of which machines could handle the request, only that one actor in the cluster would handle it. Akka&amp;rsquo;s provides exactly these capabilities using the DistributedPubSubExtension provided in Akka&amp;rsquo;s contrib module. This article will demonstrate how to create a clustered service using the DistributedPubSubExtension.
&lt;p&gt;In our example we have two types of actors; a BackendService actor which represents some arbitrary service running in the cluster and a WebService actor which handles http requests and in turn calls a BackendService to perform some work. The BackendService is stateless and there are many running in the cluster. The WebService just need to call any one BackendService to have the work performed.&lt;/p&gt;

&lt;h2 id=&#34;the-distributedpubsubmediator&#34;&gt;The DistributedPubSubMediator&lt;/h2&gt;

&lt;p&gt;Both the WebService and the BackEndService create a DistributedPubSubMediator. The DistributedPubSubMediator is an actor that maintains a registry of other ActorRefs and distributes them to peers around the network. This allows clients to refer actors by role instead of by a specific address. It also allows actors to join or leave the cluster and the mediator will track which actors are currently active.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  val mediator = DistributedPubSubExtension(context.system).mediator
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;backend-service-implementation&#34;&gt;Backend Service Implementation&lt;/h2&gt;

&lt;p&gt;In our BackendServiceActor constructor we simply need to create the mediator and register our actor with it. The mediator will in turn update all its peer mediators in the cluster informing them that our BackendServiceActor has joined the cluster&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  mediator ! Put(self)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rest of the BackendActor is a standard Actor implementation where we listen for messages in a receive method&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def receive = {
    case PerformWork =&amp;gt;
      log.info(&amp;quot;Backend Service is performing some work&amp;quot;)
      sender() ! OK
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-web-service&#34;&gt;The Web Service&lt;/h2&gt;

&lt;p&gt;For our Web service we will use Spray.io which is a library built on top of Akka that provides all the functionality we need to process http requests. To use Spray we create an actor that inherits from the HttpService trait.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;   class WebServiceActor extends Actor with HttpService
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like in the BackendService actor, we need to create a mediator in the HttpService constructor. Then we can send messages to the BackendService via the mediator&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;mediator ? Send(&amp;quot;/user/backend-service&amp;quot;, PerformWork, false)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with all actors we need to implement a &amp;lsquo;receive&amp;rsquo; method. Our receive method will provide http routing information to Spray so it knows how to handle requests. Spray provides a DSL for doing this. In our example we implement just one route &amp;ldquo;dowork&amp;rdquo; in order to see our cluster in action&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def receive = runRoute {
    path(&amp;quot;dowork&amp;quot;) {
      onComplete(mediator ? Send(&amp;quot;/user/backend-service&amp;quot;, PerformWork, false)) {
        case Success(value) =&amp;gt; complete(&amp;quot;OK&amp;quot;)
        case Failure(e) =&amp;gt; complete(e.getMessage)
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##Configuration
Both services need to provide configuration information to the ActorSystems. In the application.conf file we need to add the extension class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  extensions = [
    &amp;quot;akka.contrib.pattern.DistributedPubSubExtension&amp;quot;
  ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also configure the PubSubExtension with the following properties&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;akka.contrib.cluster.pub-sub {
  # Actor name of the mediator actor, /user/distributedPubSubMediator
  name = distributedPubSubMediator

  # Start the mediator on members tagged with this role.
  # All members are used if undefined or empty.
  role = &amp;quot;&amp;quot;

  # How often the DistributedPubSubMediator should send out gossip information
  gossip-interval = 1s

  # Removed entries are pruned after this duration
  removed-time-to-live = 120s
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##Conclusion
A complete example that can run is available  &lt;a href=&#34;https://github.com/eweise/akka-pubsub-cluster-example&#34;&gt;here&lt;/a&gt;. Try booting up multiple BackendService instances. You will notice that the router selects actors randomly which is the default but can be changed to other strategies including round-robin. One issue I see in the example is that a delay occurs handling requests when a BackendService leaves the cluster, potentially causing the WebService requests to timeout for a brief time. This could possibly be hardened by adding retry logic into the Webservice. Overall Akka provides an incredible amount of functionality and the contrib module builds on top of the core features to making implementing clustered services almost trivial.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>